import type { Meta, StoryObj } from '@storybook/react';
import { expect, within } from 'storybook/test';
import { ApolloProvider, useApolloClient, gql } from '@apollo/client';
import { AuthProvider } from 'react-oidc-context';
import { MemoryRouter } from 'react-router-dom';
import { useState, useRef } from 'react';
import { ApolloConnection } from './index.tsx';
import {
  client
} from './apollo-client-links.tsx';

// Mock environment variables
const mockEnv = {
  VITE_FUNCTION_ENDPOINT: 'https://mock-functions.example.com',
  VITE_AAD_B2C_ACCOUNT_AUTHORITY: 'https://mock-authority.example.com',
  VITE_AAD_B2C_ACCOUNT_CLIENTID: 'mock-client-id',
  NODE_ENV: 'development',
  PROD: false,
};

// Mock window.sessionStorage and window.localStorage
const mockStorage = {
  getItem: (key: string) => {
    if (key.includes('oidc.user')) {
      return JSON.stringify({
        access_token: 'fallback-access-token',
        profile: { sub: 'fallback-user' },
      });
    }
    return null;
  },
  setItem: (_key: string, _value: string) => Promise.resolve(),
  removeItem: (_key: string) => Promise.resolve(),
  clear: () => Promise.resolve(),
  key: () => null,
  length: 0,
  set: (_key: string, _value: string) => Promise.resolve(),
  get: (key: string) => Promise.resolve(mockStorage.getItem(key)),
  remove: (key: string) => Promise.resolve(key),
  getAllKeys: () => Promise.resolve([]),
};

// Setup global mocks
Object.defineProperty(window, 'sessionStorage', { value: mockStorage, writable: true });
Object.defineProperty(window, 'localStorage', { value: mockStorage, writable: true });

// Mock import.meta.env
Object.defineProperty(import.meta, 'env', {
  value: mockEnv,
  writable: true,
});

const meta = {
  title: 'Components/UI/Organisms/ApolloConnection/Apollo Client Links',
  parameters: {
    layout: 'fullscreen',
    docs: {
      description: {
        component: 'Utility functions for creating Apollo Client links with authentication, custom headers, and GraphQL server configuration. These stories demonstrate how the link functions work within the ApolloConnection component.',
      },
    },
  },
  decorators: [
    (Story) => (
      <AuthProvider
        authority={mockEnv.VITE_AAD_B2C_ACCOUNT_AUTHORITY}
        client_id={mockEnv.VITE_AAD_B2C_ACCOUNT_CLIENTID}
        redirect_uri={window.location.origin}
        post_logout_redirect_uri={window.location.origin}
        userStore={mockStorage}
      >
        <ApolloProvider client={client}>
          <MemoryRouter initialEntries={['/accounts']}>
            <Story />
          </MemoryRouter>
        </ApolloProvider>
      </AuthProvider>
    ),
  ],
} satisfies Meta<typeof ApolloConnection>;

export default meta;
type Story = StoryObj<typeof meta>;

// Test component that verifies Apollo link functionality
const ApolloLinkTester = () => {
  const apolloClient = useApolloClient();
  const [authResult, setAuthResult] = useState<string | null>(null);
  const [headersResult, setHeadersResult] = useState<string | null>(null);
  const authButtonRef = useRef<HTMLButtonElement>(null);
  const headersButtonRef = useRef<HTMLButtonElement>(null);

  const testAuthHeader = async () => {
    try {
      // This will test if the auth header link is working
      const result = await apolloClient.query({
        query: gql`
          query TestQuery {
            __typename
          }
        `,
        fetchPolicy: 'network-only'
      });
      const resultData = { success: true, data: result.data };
      setAuthResult(JSON.stringify(resultData));
      return resultData;
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      const resultData = { success: false, error: errorMessage };
      setAuthResult(JSON.stringify(resultData));
      return resultData;
    }
  };

  const testCustomHeaders = () => {
    // Test that custom headers are being set
    const { link } = apolloClient;
    const resultData = { linkType: link.constructor.name };
    setHeadersResult(JSON.stringify(resultData));
    return resultData;
  };

  return (
    <div data-testid="apollo-link-tester">
      <button
        ref={authButtonRef}
        type="button"
        data-testid="test-auth-button"
        data-result={authResult}
        onClick={testAuthHeader}
      >
        Test Auth Header
      </button>
      <button
        ref={headersButtonRef}
        type="button"
        data-testid="test-headers-button"
        data-result={headersResult}
        onClick={testCustomHeaders}
      >
        Test Custom Headers
      </button>
      <div data-testid="client-info">
        <strong>Client Link Chain:</strong> {apolloClient.link.constructor.name}
      </div>
    </div>
  );
};

// Story demonstrating Auth Header Link
export const AuthHeaderLinkDemo: Story = {
  name: 'Authentication Header Link',
  render: () => <ApolloLinkTester />,
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const authButton = await canvas.findByTestId('test-auth-button');

    // Click the test button to verify auth header functionality
    await authButton.click();

    // Wait for the result to be set
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify the button received a result (this tests the auth link chain)
    const result = authButton.getAttribute('data-result');
    expect(result).toBeTruthy();

    const parsedResult = JSON.parse(result as string);
    // The test should either succeed or fail with a network error (both indicate the link is working)
    expect(typeof parsedResult.success).toBe('boolean');
  },
};

// Story demonstrating Custom Header Link
export const CustomHeaderLinkDemo: Story = {
  name: 'Custom Header Link',
  render: () => <ApolloLinkTester />,
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const headersButton = await canvas.findByTestId('test-headers-button');

    // Click the test button to verify custom headers functionality
    await headersButton.click();

    // Wait for the result to be set
    await new Promise(resolve => setTimeout(resolve, 100));

    // Verify the button received a result
    const result = headersButton.getAttribute('data-result');
    expect(result).toBeTruthy();

    const parsedResult = JSON.parse(result as string);
    expect(parsedResult).toHaveProperty('linkType');
  },
};

// Story demonstrating GraphQL Server Link
export const GraphqlServerLinkDemo: Story = {
  name: 'GraphQL Server Link',
  render: () => <ApolloLinkTester />,
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const clientInfo = await canvas.findByTestId('client-info');

    // Verify the client has the terminating link configured
    expect(clientInfo).toHaveTextContent('Client Link Chain');
    expect(clientInfo.textContent).toMatch(/Client Link Chain:/);
  },
};

// Story demonstrating Apollo Client Instance
export const ApolloClientDemo: Story = {
  name: 'Apollo Client Instance',
  render: () => <ApolloLinkTester />,
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const clientInfo = await canvas.findByTestId('client-info');

    // Verify the client is properly configured with links
    expect(clientInfo).toHaveTextContent('Client Link Chain');
    expect(clientInfo.textContent).toMatch(/Client Link Chain:/);

    // Verify we can access the Apollo client
    const authButton = await canvas.findByTestId('test-auth-button');
    expect(authButton).toBeInTheDocument();
  },
};

// Story demonstrating Link Chaining
export const LinkChainingDemo: Story = {
  name: 'Link Chaining',
  render: () => <ApolloLinkTester />,
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const clientInfo = await canvas.findByTestId('client-info');

    // Verify the link chain is properly configured
    expect(clientInfo).toHaveTextContent('Client Link Chain');
    expect(clientInfo.textContent).toMatch(/Client Link Chain:/);

    // Verify all test buttons are present (representing different link types)
    const authButton = await canvas.findByTestId('test-auth-button');
    const headersButton = await canvas.findByTestId('test-headers-button');
    expect(authButton).toBeInTheDocument();
    expect(headersButton).toBeInTheDocument();
  },
};

// Story showing the complete ApolloConnection usage
export const ApolloConnectionIntegration: Story = {
  name: 'Apollo Connection Integration',
  render: () => (
    <ApolloConnection>
      <ApolloLinkTester />
    </ApolloConnection>
  ),
  play: async ({ canvasElement }: { canvasElement: HTMLElement }) => {
    const canvas = within(canvasElement);
    const tester = await canvas.findByTestId('apollo-link-tester');

    // Verify the ApolloConnection component renders with the tester
    expect(tester).toBeInTheDocument();

    // Verify all test buttons are present within the connection context
    const authButton = await canvas.findByTestId('test-auth-button');
    const headersButton = await canvas.findByTestId('test-headers-button');
    expect(authButton).toBeInTheDocument();
    expect(headersButton).toBeInTheDocument();

    // Verify client info is displayed
    const clientInfo = await canvas.findByTestId('client-info');
    expect(clientInfo).toHaveTextContent('Client Link Chain');
  },
};