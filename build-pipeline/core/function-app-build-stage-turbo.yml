parameters:
- name: vmImageName
  displayName: 'VM Image - ubuntu-latest'
  type: string
- name: npm_config_cache
  displayName: 'NPM Config Cache Location'
  type: string
- name: isNpmCacheAvailable
  displayName: 'Flag to indicate if NPM cache is available'
  type: string
- name: disableSonarCloudTasks
  displayName: 'Flag to disable SonarCloud tasks'
  type: string
- name: SONAR_USER_HOME
  displayName: 'SonarCloud User Home'
  type: string
- name: SonarCloud
  displayName: 'SonarCloud'
  type: string
- name: SonarCloud_organization
  displayName: 'SonarCloud Organization'
  type: string
- name: SonarCloud_scannerMode
  displayName: 'SonarCloud Scanner Mode'
  type: string
- name: SonarCloud_configMode
  displayName: 'SonarCloud Config Mode'
  type: string
- name: SonarCloud_cliProjectKey
  displayName: 'SonarCloud CLI Project Key'
  type: string
- name: SonarCloud_cliProjectName
  displayName: 'SonarCloud CLI Project Name'
  type: string
- name: enableTurboRemoteCache
  displayName: 'Enable Turbo Remote Cache'
  type: string
  default: 'true'

stages:
- stage: Build
  displayName: Build stage
  jobs:
  - job: Build 
    displayName: Build
    pool:
      vmImage: ${{parameters.vmImageName}}
    variables:
      PLAYWRIGHT_BROWSERS_PATH: $(Pipeline.Workspace)/.cache/ms-playwright
      TURBO_CACHE_DIR: $(Pipeline.Workspace)/.turbo
    steps:
    - checkout: self
      fetchDepth: 0 # Fetch all history for all branches and tags necessary for sonar cloud analysis 
      # SonarCloud documentation https://docs.sonarsource.com/sonarqube-server/latest/analyzing-source-code/scm-integration/#:~:text=A%20full%20clone%20is%20required%20for%20this%20integration%20to%20be%20able%20to%20collect%20the%20required%20blame%20information%20(see%20Known%20Issues).%20If%20a%20shallow%20clone%20is%20detected%2C%20a%20warning%20will%20be%20logged%20and%20no%20attempt%20will%20be%20made%20to%20retrieve%20blame%20information.

    # Ensure the correct version of Node is installed.
    - task: NodeTool@0
      displayName: 'Install: Node.js - LTS'
      inputs:
        versionSpec: '22.x'

    # Ensure the correct version of function tools are installed.
    - task: FuncToolsInstaller@0
      inputs:
        version: '4.2.1'
      displayName: 'Install: func tools - latest'

    # Playwright: Restore browsers cache
    - task: Cache@2
      displayName: 'Playwright: Restore browsers cache'
      continueOnError: true
      inputs:
        key: 'playwright | "$(Agent.OS)" | $(Build.SourcesDirectory)/package-lock.json'
        restoreKeys: |
          playwright | "$(Agent.OS)"
        path: '$(PLAYWRIGHT_BROWSERS_PATH)'
        cacheHitVar: PW_CACHE_HIT

    # Playwright: Install browsers if needed
    - task: Bash@3
      displayName: 'Playwright: Install browsers if needed'
      condition: ne(variables.PW_CACHE_HIT, 'true')
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "PW_CACHE_HIT=${PW_CACHE_HIT:-unset}"
          echo "Installing Playwright browsers into: $(PLAYWRIGHT_BROWSERS_PATH)"
          npx playwright install --with-deps chromium
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Cache NPM packages to speed up build process.
    - task: Cache@2
      displayName: 'NPM: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, True))
      inputs:
        key: 'npm | "$(Agent.OS)" | $(Build.SourcesDirectory)/package-lock.json'
        restoreKeys: |
            npm | "$(Agent.OS)"
        path: ${{parameters.npm_config_cache}}

    # Cache Turbo to speed up build process.
    - task: Cache@2
      displayName: 'Turbo: Restore Local Cache'
      inputs:
        key: 'turbo | "$(Agent.OS)" | $(Build.SourcesDirectory)/package-lock.json | $(Build.SourceVersion)'
        restoreKeys: |
            turbo | "$(Agent.OS)" | $(Build.SourcesDirectory)/package-lock.json
            turbo | "$(Agent.OS)"
        path: '$(TURBO_CACHE_DIR)'

    # Detect changes and set pipeline variables
    - task: Bash@3
      displayName: 'Turbo: Detect changes'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          
          # Determine base branch for change detection
          if [ "$(Build.Reason)" = "PullRequest" ]; then
            BASE_BRANCH="origin/$(System.PullRequest.TargetBranch)"
          else
            BASE_BRANCH="HEAD^1"
          fi
          
          echo "Using base branch: $BASE_BRANCH for change detection"
          
          # Check if we have frontend or backend changes
          HAS_FRONTEND=$(node scripts/turbo-utils.js has-frontend-changes "$BASE_BRANCH" || echo "false")
          HAS_BACKEND=$(node scripts/turbo-utils.js has-backend-changes "$BASE_BRANCH" || echo "false")
          
          echo "Has frontend changes: $HAS_FRONTEND"
          echo "Has backend changes: $HAS_BACKEND"
          
          # Set pipeline variables
          echo "##vso[task.setvariable variable=HAS_FRONTEND_CHANGES]$HAS_FRONTEND"
          echo "##vso[task.setvariable variable=HAS_BACKEND_CHANGES]$HAS_BACKEND"
          echo "##vso[task.setvariable variable=BASE_BRANCH]$BASE_BRANCH"

    # Install dependencies
    - task: Bash@3
      displayName: 'NPM: Install dependencies'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, False))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          npm install
        workingDirectory: ''

    - task: Bash@3
      displayName: 'NPM: Install dependencies using cache'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, True))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          npm ci
        workingDirectory: ''

    # Build and test affected packages
    - task: Bash@3
      displayName: 'Turbo: Build affected packages'
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          
          # Build affected packages
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Building affected packages only..."
            npx turbo run build --filter="[$(BASE_BRANCH)]"
          else
            echo "Building all packages (main branch)..."
            npx turbo run build
          fi
        workingDirectory: ''
      env:
        TURBO_TEAM: $(TURBO_TEAM)
        TURBO_TOKEN: $(TURBO_TOKEN)
        TURBO_CACHE_DIR: $(TURBO_CACHE_DIR)
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Run tests on affected packages  
    - task: Bash@3
      displayName: 'Turbo: Test affected packages'
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          
          # Test affected packages with coverage
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Testing affected packages only..."
            npx turbo run test:coverage --filter="[$(BASE_BRANCH)]"
          else
            echo "Testing all packages (main branch)..."
            npx turbo run test:coverage
          fi
        workingDirectory: ''
      env:
        TURBO_TEAM: $(TURBO_TEAM)
        TURBO_TOKEN: $(TURBO_TOKEN)
        TURBO_CACHE_DIR: $(TURBO_CACHE_DIR)
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Discover LCOV reports for affected packages only
    - task: Bash@3
      displayName: 'SonarCloud: Discover LCOV report files for affected packages'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          ROOT="$(Build.SourcesDirectory)"
          
          # Get list of affected packages for SonarCloud analysis
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Analyzing affected packages only..."
            AFFECTED_PACKAGES=$(node scripts/turbo-utils.js categorize-affected "$(BASE_BRANCH)" | jq -r '.frontend + .backend | .[]' || echo "")
          else
            echo "Analyzing all packages (main branch)..."
            AFFECTED_PACKAGES=$(node scripts/turbo-utils.js categorize-all | jq -r '.frontend + .backend | .[]' || echo "")
          fi
          
          if [ -z "$AFFECTED_PACKAGES" ]; then
            echo "No affected packages found. Setting default coverage path."
            echo "##vso[task.setvariable variable=SONAR_LCOV_PATHS]coverage/lcov.info"
          else
            echo "Affected packages for SonarCloud analysis:"
            echo "$AFFECTED_PACKAGES"
            
            # Find lcov.info files for affected packages only
            LCOV_FILES=""
            for package in $AFFECTED_PACKAGES; do
              LCOV_PATH="$ROOT/packages/$package/coverage/lcov.info"
              if [ -f "$LCOV_PATH" ]; then
                if [ -z "$LCOV_FILES" ]; then
                  LCOV_FILES="$LCOV_PATH"
                else
                  LCOV_FILES="$LCOV_FILES,$LCOV_PATH"
                fi
                echo " - Found: $LCOV_PATH"
              fi
            done
            
            if [ -z "$LCOV_FILES" ]; then
              echo "No lcov.info files found for affected packages. Coverage may show as 0%."
              echo "##vso[task.setvariable variable=SONAR_LCOV_PATHS]coverage/lcov.info"
            else
              echo "##vso[task.setvariable variable=SONAR_LCOV_PATHS]$LCOV_FILES"
            fi
          fi

    # Cache SonarCloud downloaded assets to speed up build process.
    - task: Cache@2
      displayName: 'SonarCloud: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        key: 'sonarcloud | "$(Agent.OS)"'
        restoreKeys: |
          sonarcloud | "$(Agent.OS)"
        path: ${{parameters.SONAR_USER_HOME}}/cache

    # Set up SonarCloud for affected packages
    - task: SonarCloudPrepare@3
      displayName: 'SonarCloud: Prepare analysis configuration'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}
        scannerMode: ${{parameters.SonarCloud_scannerMode}}
        configMode: ${{parameters.SonarCloud_configMode}}
        cliProjectKey: ${{parameters.SonarCloud_cliProjectKey}}
        cliProjectName: ${{parameters.SonarCloud_cliProjectName}}
        cliSources: '$(Build.SourcesDirectory)'
        extraProperties: |
          sonar.javascript.lcov.reportPaths=$(SONAR_LCOV_PATHS)
          sonar.typescript.lcov.reportPaths=$(SONAR_LCOV_PATHS)
          sonar.scanner.metadataFilePath=$(Agent.TempDirectory)/sonar/$(Build.BuildNumber)/test/report-task.txt
          sonar.cpd.exclusions=**/*.test.ts,**/generated.tsx
          sonar.coverage.exclusions=**/*.config.ts,**/tsconfig.json,**/.storybook/**,**/*.stories.ts,**/*.stories.tsx,**/*.test.ts,**/*.test.tsx,**/generated.ts,**/generated.tsx,**/*.d.ts,dist/**,packages/docs/src/test/**

    # SonarCloud: Analyze code and code coverage
    - task: SonarCloudAnalyze@3
      displayName: 'SonarCloud: Run analysis'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))

    # SonarCloud: Publish analysis results and wait until completion
    - task: SonarCloudPublish@3
      displayName: 'SonarCloud: Publish results on build summary'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        pollingTimeoutSec: '300'

    # SonarCloud: Break the build if it doesn't pass the Quality Gate
    - task: sonarcloud-buildbreaker@2
      displayName: 'SonarCloud: Break the build if it does not pass the Quality'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}

    # Package compiled assets into artifact
    - task: ArchiveFiles@2
      displayName: 'Artifact: Prepare'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
        replaceExistingArchive: true

    # Upload artifact as build result
    - publish: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
      displayName: 'Artifact: Publish'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      artifact: drop