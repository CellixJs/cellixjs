parameters:
- name: vmImageName
  displayName: 'VM Image - ubuntu-latest'
  type: string
- name: npm_config_cache
  displayName: 'NPM Config Cache Location'
  type: string
- name: isNpmCacheAvailable
  displayName: 'Flag to indicate if NPM cache is available'
  type: string
- name: disableSonarCloudTasks
  displayName: 'Flag to disable SonarCloud tasks'
  type: string
- name: SONAR_USER_HOME
  displayName: 'SonarCloud User Home'
  type: string
- name: SonarCloud
  displayName: 'SonarCloud'
  type: string
- name: SonarCloud_organization
  displayName: 'SonarCloud Organization'
  type: string
- name: SonarCloud_scannerMode
  displayName: 'SonarCloud Scanner Mode'
  type: string
- name: SonarCloud_configMode
  displayName: 'SonarCloud Config Mode'
  type: string
- name: SonarCloud_cliProjectKey
  displayName: 'SonarCloud CLI Project Key'
  type: string
- name: SonarCloud_cliProjectName
  displayName: 'SonarCloud CLI Project Name'
  type: string

stages:
- stage: Build
  displayName: Build stage
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: ${{parameters.vmImageName}}
    variables:
      PLAYWRIGHT_BROWSERS_PATH: /home/vsts/.cache/ms-playwright
      TURBO_CACHE_DIR: $(Build.SourcesDirectory)/.turbo
    steps:
    - checkout: self
      fetchDepth: 0 # Fetch all history for all branches and tags necessary for sonar cloud analysis
      # SonarCloud documentation https://docs.sonarsource.com/sonarqube-server/latest/analyzing-source-code/scm-integration/#:~:text=A%20full%20clone%20is%20required%20for%20this%20integration%20to%20be%20able%20to%20collect%20the%20required%20blame%20information%20(see%20Known%20Issues).%20If%20a%20shallow%20clone%20is%20detected%2C%20a%20warning%20will%20be%20logged%20and%20no%20attempt%20will%20be%20made%20to%20retrieve%20blame%20information.

    # Ensure the correct version of Node is installed.
    - task: NodeTool@0
      displayName: 'Install: Node.js - LTS'
      inputs:
        versionSpec: '22.x'

    # Cache Azure Functions Core Tools
    - task: Cache@2
      displayName: 'Azure Functions: Restore Core Tools Cache'
      inputs:
        key: 'func-tools | "$(Agent.OS)" | "4.2.1"'
        restoreKeys: |
          func-tools | "$(Agent.OS)"
        path: '/opt/hostedtoolcache/func'
        cacheHitVar: FUNC_TOOLS_CACHE_HIT

    # Ensure the correct version of function tools are installed.
    - task: FuncToolsInstaller@0
      displayName: 'Install: func tools - 4.2.1'
      condition: and(ne(variables.FUNC_TOOLS_CACHE_HIT, 'true'), ne(variables.FUNC_TOOLS_CACHE_HIT, 'inexact'))
      inputs:
        version: '4.2.1'
        
    # Playwright: Restore browsers cache
    - task: Cache@2
      displayName: 'Playwright: Restore browsers cache'
      continueOnError: true
      inputs:
        key: 'playwright | "$(Agent.OS)" | ubuntu-latest | node-22'
        restoreKeys: |
          playwright | "$(Agent.OS)" | ubuntu-latest
          playwright | "$(Agent.OS)"
        path: '$(PLAYWRIGHT_BROWSERS_PATH)'
        cacheHitVar: PW_CACHE_HIT

    # Playwright: Install browsers if needed
    - task: Bash@3
      displayName: 'Playwright: Install browsers if needed'
      condition: and(ne(variables.PW_CACHE_HIT, 'true'), ne(variables.PW_CACHE_HIT, 'inexact'))
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "PW_CACHE_HIT=${PW_CACHE_HIT:-unset}"
          echo "Installing Playwright browsers into: $(PLAYWRIGHT_BROWSERS_PATH)"
          mkdir -p "$(PLAYWRIGHT_BROWSERS_PATH)"
          npx playwright install --with-deps
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Playwright: Ensure browsers are available for packages that need them
    - task: Bash@3
      displayName: 'Playwright: Verify browser installation'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Verifying Playwright browser installation..."
          echo "PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)"

          # Check if browsers are installed
          if [ ! -d "$(PLAYWRIGHT_BROWSERS_PATH)" ] || [ -z "$(ls -A "$(PLAYWRIGHT_BROWSERS_PATH)" 2>/dev/null || echo '')" ]; then
            echo "Browsers not found in cache, installing them..."
            mkdir -p "$(PLAYWRIGHT_BROWSERS_PATH)"
            npx playwright install --with-deps
          fi

          # Explicitly ensure chromium headless shell is available (used by Vitest browser provider)
          if ! find "$(PLAYWRIGHT_BROWSERS_PATH)" -maxdepth 2 -type d -name 'chromium_headless_shell-*' | grep -q chromium_headless_shell; then
            echo "chromium_headless_shell not found; reinstalling browsers to fetch it..."
            npx playwright install --with-deps
          fi

          echo "Installed browsers:"
          ls -la "$(PLAYWRIGHT_BROWSERS_PATH)" || true

          # Make sure browser binaries are executable
          find "$(PLAYWRIGHT_BROWSERS_PATH)" -type f -name "*chrome*" -exec chmod +x {} \; 2>/dev/null || true
          find "$(PLAYWRIGHT_BROWSERS_PATH)" -type f -name "headless_shell" -exec chmod +x {} \; 2>/dev/null || true
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

      displayName: 'Playwright: Setup browsers'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Cache restored: ${PW_CACHE_RESTORED:-false}"
          echo "Browser path: $(PLAYWRIGHT_BROWSERS_PATH)"

          # Create directory if it doesn't exist
          mkdir -p "$(PLAYWRIGHT_BROWSERS_PATH)"

          # Check if we have a valid browser installation
          CACHE_VALID=false
          if [ "${PW_CACHE_RESTORED:-false}" = "true" ] || [ "${PW_CACHE_RESTORED:-false}" = "inexact" ]; then
            echo "✓ Browser cache found - checking validity..."

            # Check for browser directories (more reliable than executables)
            if [ -d "$(PLAYWRIGHT_BROWSERS_PATH)/chromium" ] && [ -d "$(PLAYWRIGHT_BROWSERS_PATH)/firefox" ]; then
              echo "✓ Browser directories found"

              # Try to find any chromium executable
              if find "$(PLAYWRIGHT_BROWSERS_PATH)/chromium" -name "*chrome*" -type f -executable 2>/dev/null | grep -q .; then
                echo "✓ Chromium executable found"
                CACHE_VALID=true
              else
                echo "⚠ No chromium executable found"
              fi

              # Try to find any firefox executable
              if find "$(PLAYWRIGHT_BROWSERS_PATH)/firefox" -name "*firefox*" -type f -executable 2>/dev/null | grep -q .; then
                echo "✓ Firefox executable found"
                CACHE_VALID=true
              else
                echo "⚠ No firefox executable found"
              fi
            else
              echo "⚠ Browser directories not found"
            fi
          fi

          if [ "$CACHE_VALID" = "true" ]; then
            echo "✓ Using cached browsers - installing only system dependencies..."
            npx playwright install-deps
          else
            echo "⚠ Installing browsers from scratch..."
            npx playwright install --with-deps
          fi

          # Ensure chromium headless shell is available (for Vitest)
          if ! find "$(PLAYWRIGHT_BROWSERS_PATH)" -name "*headless*" -type f 2>/dev/null | grep -q .; then
            echo "Installing chromium headless shell..."
            npx playwright install chromium-headless-shell
          fi

          # Make all binaries executable (just in case)
          find "$(PLAYWRIGHT_BROWSERS_PATH)" -type f \( -name "*chrome*" -o -name "*firefox*" -o -name "*headless*" \) -exec chmod +x {} \; 2>/dev/null || true

          echo "✓ Browser setup complete"
          echo "Cache status: ${PW_CACHE_RESTORED:-false}"
          echo "Cache valid: $CACHE_VALID"
          ls -la "$(PLAYWRIGHT_BROWSERS_PATH)" | head -10
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

    # Cache NPM packages to speed up build process.
    - task: Cache@2
      displayName: 'NPM: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, True))
      inputs:
        key: 'npm | "$(Agent.OS)" | $(Build.SourcesDirectory)/package-lock.json'
        restoreKeys: |
            npm | "$(Agent.OS)"
        path: ${{parameters.npm_config_cache}}

    # Detect affected packages and set output variables for deployment stage
    - task: Bash@3
      displayName: 'Detect affected package types'
      name: BuildJob
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          
          # Determine base branch for change detection (for logging only)
          if [ "$(Build.Reason)" = "PullRequest" ]; then
            TARGET_BRANCH="origin/$(System.PullRequest.TargetBranch)"
            BASE_BRANCH=$(git merge-base $TARGET_BRANCH HEAD)
            echo "PR build - comparing current branch to: $TARGET_BRANCH (merge-base: $BASE_BRANCH)"
          else
            BASE_BRANCH="HEAD~1"
            echo "Push build - comparing to previous commit: $BASE_BRANCH"
          fi
          
          # Check if frontend or backend packages are affected using Turbo's --affected
          HAS_FRONTEND_CHANGES=false
          HAS_BACKEND_CHANGES=false
          HAS_DOCS_CHANGES=false
          
          # Use Turbo's --affected to get affected packages with better output parsing
          echo "Running turbo to detect affected packages..."
          TURBO_OUTPUT=$(npx turbo run build --affected --dry-run 2>&1 || echo "TURBO_FAILED")
          
          echo "Turbo output:"
          echo "$TURBO_OUTPUT"
          
          # Check if turbo found affected packages
          if echo "$TURBO_OUTPUT" | grep -q "Packages in Scope"; then
            echo "Found affected packages in turbo output"
            
            # Extract package names from turbo output - try multiple patterns
            AFFECTED_PACKAGES=$(echo "$TURBO_OUTPUT" | grep -E "(packages/|@.*/)" | sed -E 's/.*packages\/([^/]+).*/\1/' | sed -E 's/@([^/]+)\/.*/\1/' | sort | uniq || echo "")
            
            # If no packages found with above, try a broader search
            if [ -z "$AFFECTED_PACKAGES" ]; then
              AFFECTED_PACKAGES=$(echo "$TURBO_OUTPUT" | grep -oE '[^[:space:]]+@[0-9]+\.[0-9]+\.[0-9]+' | sed 's/@.*//' | sort | uniq || echo "")
            fi
            
            echo "Parsed affected packages: $AFFECTED_PACKAGES"
            
            # If still no packages found, check if this is a new branch or major change
            if [ -z "$AFFECTED_PACKAGES" ]; then
              echo "No specific packages parsed, checking if this affects all packages..."
              # For major changes or new branches, assume all packages are affected
              if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
                echo "Major change detected - marking all package types as affected"
                HAS_FRONTEND_CHANGES=true
                HAS_BACKEND_CHANGES=true
                HAS_DOCS_CHANGES=true
              fi
            else
              # Check each affected package
              for package in $AFFECTED_PACKAGES; do
                echo "Processing package: $package"
                if [[ $package == ui-* ]] || [[ $package == cellix-ui-core ]] || [[ $package == *ui* ]]; then
                  HAS_FRONTEND_CHANGES=true
                  echo "Frontend package detected: $package"
                elif [[ $package == docs ]] || [[ $package == *docs* ]]; then
                  HAS_DOCS_CHANGES=true
                  echo "Docs package detected: $package"
                else
                  HAS_BACKEND_CHANGES=true
                  echo "Backend package detected: $package"
                fi
              done
            fi
          else
            echo "No 'Packages in Scope' found in turbo output"
            # For PRs or main branch pushes, assume broad impact
            if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
              echo "PR or main branch change - assuming broad impact"
              HAS_FRONTEND_CHANGES=true
              HAS_BACKEND_CHANGES=true
              HAS_DOCS_CHANGES=true
            fi
          fi
          
          echo "Final results:"
          echo "Frontend changes: $HAS_FRONTEND_CHANGES"
          echo "Backend changes: $HAS_BACKEND_CHANGES"
          echo "Docs changes: $HAS_DOCS_CHANGES"
          
          # Set pipeline variables as outputs for deployment stage
          echo "##vso[task.setvariable variable=HAS_FRONTEND_CHANGES;isOutput=true]$HAS_FRONTEND_CHANGES"
          echo "##vso[task.setvariable variable=HAS_BACKEND_CHANGES;isOutput=true]$HAS_BACKEND_CHANGES"
          echo "##vso[task.setvariable variable=HAS_DOCS_CHANGES;isOutput=true]$HAS_DOCS_CHANGES"
          echo "##vso[task.setvariable variable=BASE_BRANCH]$BASE_BRANCH"

    # Cache Turbo to speed up build process.
    - task: Cache@2
      displayName: 'Turbo: Restore Local Cache'
      inputs:
        key: 'turbo | "$(Agent.OS)" | $(Build.SourcesDirectory)/turbo.json'
        restoreKeys: |
          turbo | "$(Agent.OS)"
        path: '$(TURBO_CACHE_DIR)'

    # Install dependencies
    - task: Bash@3
      displayName: 'NPM: Install dependencies'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, False))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          npm install
        workingDirectory: ''

    - task: Bash@3
      displayName: 'NPM: Install dependencies using cache'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, True))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          npm ci
        workingDirectory: ''

    # Build affected packages using Turbo's built-in --affected flag
    - task: Bash@3
      displayName: 'Turbo: Build affected packages'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          export NODE_OPTIONS=--max_old_space_size=16384
          
          # Use Turbo's built-in --affected flag for accurate change detection
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Building affected packages only using Turbo's --affected..."
            npm run build -- --affected
          else
            echo "Building all packages (main branch)..."
            npm run build
          fi
        workingDirectory: ''
      env:
        TURBO_CACHE_DIR: $(TURBO_CACHE_DIR)
        TURBO_TELEMETRY_DISABLED: 1
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

        # Run tests on affected packages using Turbo's --affected flag
    - task: Bash@3
      displayName: 'Turbo: Test affected packages with coverage merge'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          export NODE_OPTIONS=--max_old_space_size=16384
          export PLAYWRIGHT_BROWSERS_PATH="$(PLAYWRIGHT_BROWSERS_PATH)"
          
          # Use Turbo's built-in --affected flag for accurate change detection
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Testing affected packages only using Turbo's --affected..."
            npm run test:coverage -- --affected && npm run merge-lcov-reports
          else
            echo "Testing all packages (main branch)..."
            npm run test:coverage:merge
          fi
          
          # Set the merged coverage path for SonarCloud
          echo "##vso[task.setvariable variable=SONAR_LCOV_PATHS]coverage/lcov.info"
        workingDirectory: ''
      env:
        TURBO_CACHE_DIR: $(TURBO_CACHE_DIR)
        TURBO_TELEMETRY_DISABLED: 1
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)
    # Cache SonarCloud downloaded assets to speed up build process.
    - task: Cache@2
      displayName: 'SonarCloud: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        key: 'sonarcloud | "$(Agent.OS)"'
        restoreKeys: |
          sonarcloud | "$(Agent.OS)"
        path: ${{parameters.SONAR_USER_HOME}}/cache

    # Set up SonarCloud for affected packages
    - task: SonarCloudPrepare@3
      displayName: 'SonarCloud: Prepare analysis configuration'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}
        scannerMode: ${{parameters.SonarCloud_scannerMode}}
        configMode: ${{parameters.SonarCloud_configMode}}
        cliProjectKey: ${{parameters.SonarCloud_cliProjectKey}}
        cliProjectName: ${{parameters.SonarCloud_cliProjectName}}
        cliSources: '$(Build.SourcesDirectory)'
        extraProperties: |
          sonar.javascript.lcov.reportPaths=$(SONAR_LCOV_PATHS)
          sonar.typescript.lcov.reportPaths=$(SONAR_LCOV_PATHS)
          sonar.scanner.metadataFilePath=$(Agent.TempDirectory)/sonar/$(Build.BuildNumber)/test/report-task.txt
          sonar.cpd.exclusions=**/*.test.ts,**/generated.tsx
          sonar.coverage.exclusions=**/*.config.ts,**/tsconfig.json,**/.storybook/**,**/*.stories.ts,**/*.stories.tsx,**/*.test.ts,**/*.test.tsx,**/generated.ts,**/generated.tsx,**/*.d.ts,dist/**,apps/docs/src/test/**,scripts/**,packages/ocom/domain/tests/**,packages/cellix/mock-oauth2-server/**,packages/cellix/mock-mongodb-memory-server/**

    # SonarCloud: Analyze code and code coverage
    - task: SonarCloudAnalyze@3
      displayName: 'SonarCloud: Run analysis'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))

    # SonarCloud: Publish analysis results and wait until completion
    - task: SonarCloudPublish@3
      displayName: 'SonarCloud: Publish results on build summary'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        pollingTimeoutSec: '300'

    # SonarCloud: Break the build if it doesn't pass the Quality Gate
    - task: sonarcloud-buildbreaker@2
      displayName: 'SonarCloud: Break the build if it does not pass the Quality'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}

    # Package compiled assets into artifact
    - task: ArchiveFiles@2
      displayName: 'Artifact: Prepare'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
        replaceExistingArchive: true
        # Include all build outputs from packages and apps

    # Upload artifact as build result
    - publish: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
      displayName: 'Artifact: Publish'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      artifact: drop