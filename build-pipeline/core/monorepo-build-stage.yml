parameters:
- name: vmImageName
  displayName: 'VM Image - ubuntu-latest'
  type: string
- name: npm_config_cache
  displayName: 'NPM Config Cache Location'
  type: string
- name: isNpmCacheAvailable
  displayName: 'Flag to indicate if NPM cache is available'
  type: string
- name: disableSonarCloudTasks
  displayName: 'Flag to disable SonarCloud tasks'
  type: string
- name: SONAR_USER_HOME
  displayName: 'SonarCloud User Home'
  type: string
- name: SonarCloud
  displayName: 'SonarCloud'
  type: string
- name: SonarCloud_organization
  displayName: 'SonarCloud Organization'
  type: string
- name: SonarCloud_scannerMode
  displayName: 'SonarCloud Scanner Mode'
  type: string
- name: SonarCloud_configMode
  displayName: 'SonarCloud Config Mode'
  type: string
- name: SonarCloud_cliProjectKey
  displayName: 'SonarCloud CLI Project Key'
  type: string
- name: SonarCloud_cliProjectName
  displayName: 'SonarCloud CLI Project Name'
  type: string

stages:
- stage: Build
  displayName: Build stage
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: ${{parameters.vmImageName}}
    variables:
      PLAYWRIGHT_BROWSERS_PATH: /home/vsts/.cache/ms-playwright
      TURBO_CACHE_DIR: $(Build.SourcesDirectory)/.turbo
    steps:
    - checkout: self
      fetchDepth: 0 # Fetch all history for all branches and tags necessary for sonar cloud analysis
      # SonarCloud documentation https://docs.sonarsource.com/sonarqube-server/latest/analyzing-source-code/scm-integration/#:~:text=A%20full%20clone%20is%20required%20for%20this%20integration%20to%20be%20able%20to%20collect%20the%20required%20blame%20information%20(see%20Known%20Issues).%20If%20a%20shallow%20clone%20is%20detected%2C%20a%20warning%20will%20be%20logged%20and%20no%20attempt%20will%20be%20made%20to%20retrieve%20blame%20information.

    # Ensure the correct version of Node is installed.
    - task: NodeTool@0
      displayName: 'Install: Node.js - LTS'
      inputs:
        versionSpec: '22.x'

    # Cache Azure Functions Core Tools
    - task: Cache@2
      displayName: 'Azure Functions: Restore Core Tools Cache'
      inputs:
        key: 'func-tools | "$(Agent.OS)" | "4.2.1"'
        restoreKeys: |
          func-tools | "$(Agent.OS)"
        path: '/opt/hostedtoolcache/func'
        cacheHitVar: FUNC_TOOLS_CACHE_HIT

    # Ensure the correct version of function tools are installed.
    - task: FuncToolsInstaller@0
      displayName: 'Install: func tools - 4.2.1'
      condition: and(ne(variables.FUNC_TOOLS_CACHE_HIT, 'true'), ne(variables.FUNC_TOOLS_CACHE_HIT, 'inexact'))
      inputs:
        version: '4.2.1'

    # Playwright: Restore browsers cache
    - task: Cache@2
      displayName: 'Playwright: Restore browsers cache'
      continueOnError: true
      inputs:
        key: 'playwright | "$(Agent.OS)" | node-22 | browsers-v1'
        restoreKeys: |
          playwright | "$(Agent.OS)" | node-22
          playwright | "$(Agent.OS)"
        path: '$(PLAYWRIGHT_BROWSERS_PATH)'
        cacheHitVar: PW_CACHE_RESTORED

    # Playwright: Install and verify browsers
    - task: Bash@3
      displayName: 'Playwright: Setup browsers'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          echo "Cache restored: ${PW_CACHE_RESTORED:-false}"
          echo "Browser path: $(PLAYWRIGHT_BROWSERS_PATH)"

          # Create directory if it doesn't exist
          mkdir -p "$(PLAYWRIGHT_BROWSERS_PATH)"

          # Check if we have a valid browser installation by verifying executables
          CHROMIUM_EXECUTABLE="$(PLAYWRIGHT_BROWSERS_PATH)/chromium/chrome"
          FIREFOX_EXECUTABLE="$(PLAYWRIGHT_BROWSERS_PATH)/firefox/firefox"

          if [ "${PW_CACHE_RESTORED:-false}" = "true" ] && [ -x "$CHROMIUM_EXECUTABLE" ] && [ -x "$FIREFOX_EXECUTABLE" ]; then
            echo "✓ Valid browser cache found - verifying installation..."
            # Quick verification that browsers can start
            timeout 5s "$CHROMIUM_EXECUTABLE" --version >/dev/null 2>&1 && echo "✓ Chromium executable verified" || {
              echo "⚠ Chromium verification failed - reinstalling..."
              PW_CACHE_RESTORED=false
            }
            timeout 5s "$FIREFOX_EXECUTABLE" --version >/dev/null 2>&1 && echo "✓ Firefox executable verified" || {
              echo "⚠ Firefox verification failed - reinstalling..."
              PW_CACHE_RESTORED=false
            }
          else
            echo "⚠ No valid browser cache found - performing full installation..."
            PW_CACHE_RESTORED=false
          fi

          if [ "${PW_CACHE_RESTORED:-false}" = "true" ]; then
            echo "✓ Using cached browsers - installing only system dependencies..."
            npx playwright install-deps
          else
            echo "⚠ Installing browsers from scratch..."
            npx playwright install --with-deps
          fi

          # Ensure chromium headless shell is available (for Vitest)
          if ! find "$(PLAYWRIGHT_BROWSERS_PATH)" -name "chromium_headless_shell" -type f 2>/dev/null | grep -q .; then
            echo "Installing chromium headless shell..."
            npx playwright install chromium-headless-shell
          fi

          # Make binaries executable
          find "$(PLAYWRIGHT_BROWSERS_PATH)" -type f \( -name "*chrome*" -o -name "*firefox*" -o -name "headless_shell" \) -exec chmod +x {} \; 2>/dev/null || true

          echo "✓ Browser setup complete"
          echo "Cache status: ${PW_CACHE_RESTORED:-false}"
          ls -la "$(PLAYWRIGHT_BROWSERS_PATH)" | head -10
      env:
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)


    # Cache NPM packages to speed up build process.
    - task: Cache@2
      displayName: 'NPM: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, True))
      inputs:
        key: 'npm | "$(Agent.OS)" | $(Build.SourcesDirectory)/package-lock.json'
        restoreKeys: |
            npm | "$(Agent.OS)"
        path: ${{parameters.npm_config_cache}}

    # Detect affected packages and set output variables for deployment stage
    - task: Bash@3
      displayName: 'Detect affected package types'
      name: BuildJob
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          
          # Determine base branch for change detection (for logging only)
          if [ "$(Build.Reason)" = "PullRequest" ]; then
            TARGET_BRANCH="origin/$(System.PullRequest.TargetBranch)"
            BASE_BRANCH=$(git merge-base $TARGET_BRANCH HEAD)
            echo "PR build - comparing current branch to: $TARGET_BRANCH (merge-base: $BASE_BRANCH)"
          else
            BASE_BRANCH="HEAD~1"
            echo "Push build - comparing to previous commit: $BASE_BRANCH"
          fi
          
          # Check if frontend or backend packages are affected using Turbo's --affected
          HAS_FRONTEND_CHANGES=false
          HAS_BACKEND_CHANGES=false
          HAS_DOCS_CHANGES=false
          
          # Use Turbo's --affected to get affected packages with better output parsing
          echo "Running turbo to detect affected packages..."
          TURBO_OUTPUT=$(npx turbo run build --affected --dry-run 2>&1 || echo "TURBO_FAILED")
          
          echo "Turbo output:"
          echo "$TURBO_OUTPUT"
          
          # Check if turbo found affected packages
          if echo "$TURBO_OUTPUT" | grep -q "Packages in Scope"; then
            echo "Found affected packages in turbo output"
            
            # Extract package names from turbo output - try multiple patterns
            AFFECTED_PACKAGES=$(echo "$TURBO_OUTPUT" | grep -E "(packages/|@.*/)" | sed -E 's/.*packages\/([^/]+).*/\1/' | sed -E 's/@([^/]+)\/.*/\1/' | sort | uniq || echo "")
            
            # If no packages found with above, try a broader search
            if [ -z "$AFFECTED_PACKAGES" ]; then
              AFFECTED_PACKAGES=$(echo "$TURBO_OUTPUT" | grep -oE '[^[:space:]]+@[0-9]+\.[0-9]+\.[0-9]+' | sed 's/@.*//' | sort | uniq || echo "")
            fi
            
            echo "Parsed affected packages: $AFFECTED_PACKAGES"
            
            # If still no packages found, check if this is a new branch or major change
            if [ -z "$AFFECTED_PACKAGES" ]; then
              echo "No specific packages parsed, checking if this affects all packages..."
              # For major changes or new branches, assume all packages are affected
              if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
                echo "Major change detected - marking all package types as affected"
                HAS_FRONTEND_CHANGES=true
                HAS_BACKEND_CHANGES=true
                HAS_DOCS_CHANGES=true
              fi
            else
              # Check each affected package
              for package in $AFFECTED_PACKAGES; do
                echo "Processing package: $package"
                if [[ $package == ui-* ]] || [[ $package == cellix-ui-core ]] || [[ $package == *ui* ]]; then
                  HAS_FRONTEND_CHANGES=true
                  echo "Frontend package detected: $package"
                elif [[ $package == docs ]] || [[ $package == *docs* ]]; then
                  HAS_DOCS_CHANGES=true
                  echo "Docs package detected: $package"
                else
                  HAS_BACKEND_CHANGES=true
                  echo "Backend package detected: $package"
                fi
              done
            fi
          else
            echo "No 'Packages in Scope' found in turbo output"
            # For PRs or main branch pushes, assume broad impact
            if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" = "refs/heads/main" ]; then
              echo "PR or main branch change - assuming broad impact"
              HAS_FRONTEND_CHANGES=true
              HAS_BACKEND_CHANGES=true
              HAS_DOCS_CHANGES=true
            fi
          fi
          
          echo "Final results:"
          echo "Frontend changes: $HAS_FRONTEND_CHANGES"
          echo "Backend changes: $HAS_BACKEND_CHANGES"
          echo "Docs changes: $HAS_DOCS_CHANGES"
          
          # Set pipeline variables as outputs for deployment stage
          echo "##vso[task.setvariable variable=HAS_FRONTEND_CHANGES;isOutput=true]$HAS_FRONTEND_CHANGES"
          echo "##vso[task.setvariable variable=HAS_BACKEND_CHANGES;isOutput=true]$HAS_BACKEND_CHANGES"
          echo "##vso[task.setvariable variable=HAS_DOCS_CHANGES;isOutput=true]$HAS_DOCS_CHANGES"
          echo "##vso[task.setvariable variable=BASE_BRANCH]$BASE_BRANCH"

    # Cache Turbo to speed up build process.
    - task: Cache@2
      displayName: 'Turbo: Restore Local Cache'
      inputs:
        key: 'turbo | "$(Agent.OS)" | $(Build.SourcesDirectory)/turbo.json'
        restoreKeys: |
          turbo | "$(Agent.OS)"
        path: '$(TURBO_CACHE_DIR)'

    # Install dependencies
    - task: Bash@3
      displayName: 'NPM: Install dependencies'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, False))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          npm install
        workingDirectory: ''

    - task: Bash@3
      displayName: 'NPM: Install dependencies using cache'
      condition: and(succeeded(), eq(${{parameters.isNpmCacheAvailable}}, True))
      inputs:
        targetType: 'inline'
        script: |
          export NODE_OPTIONS=--max_old_space_size=16384
          npm ci
        workingDirectory: ''

    # Build affected packages using Turbo's built-in --affected flag
    - task: Bash@3
      displayName: 'Turbo: Build affected packages'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          export NODE_OPTIONS=--max_old_space_size=16384
          
          # Use Turbo's built-in --affected flag for accurate change detection
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Building affected packages only using Turbo's --affected..."
            npm run build -- --affected
          else
            echo "Building all packages (main branch)..."
            npm run build
          fi
        workingDirectory: ''
      env:
        TURBO_CACHE_DIR: $(TURBO_CACHE_DIR)
        TURBO_TELEMETRY_DISABLED: 1
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)

        # Run tests on affected packages using Turbo's --affected flag
    - task: Bash@3
      displayName: 'Turbo: Test affected packages with coverage merge'
      inputs:
        targetType: 'inline'
        script: |
          set -euo pipefail
          export NODE_OPTIONS=--max_old_space_size=16384
          export PLAYWRIGHT_BROWSERS_PATH="$(PLAYWRIGHT_BROWSERS_PATH)"
          
          # Use Turbo's built-in --affected flag for accurate change detection
          if [ "$(Build.Reason)" = "PullRequest" ] || [ "$(Build.SourceBranch)" != "refs/heads/main" ]; then
            echo "Testing affected packages only using Turbo's --affected..."
            npm run test:coverage -- --affected && npm run merge-lcov-reports
          else
            echo "Testing all packages (main branch)..."
            npm run test:coverage:merge
          fi
          
          # Set the merged coverage path for SonarCloud
          echo "##vso[task.setvariable variable=SONAR_LCOV_PATHS]coverage/lcov.info"
        workingDirectory: ''
      env:
        TURBO_CACHE_DIR: $(TURBO_CACHE_DIR)
        TURBO_TELEMETRY_DISABLED: 1
        PLAYWRIGHT_BROWSERS_PATH: $(PLAYWRIGHT_BROWSERS_PATH)
    # Cache SonarCloud downloaded assets to speed up build process.
    - task: Cache@2
      displayName: 'SonarCloud: Restore Cache'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        key: 'sonarcloud | "$(Agent.OS)"'
        restoreKeys: |
          sonarcloud | "$(Agent.OS)"
        path: ${{parameters.SONAR_USER_HOME}}/cache

    # Set up SonarCloud for affected packages
    - task: SonarCloudPrepare@3
      displayName: 'SonarCloud: Prepare analysis configuration'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}
        scannerMode: ${{parameters.SonarCloud_scannerMode}}
        configMode: ${{parameters.SonarCloud_configMode}}
        cliProjectKey: ${{parameters.SonarCloud_cliProjectKey}}
        cliProjectName: ${{parameters.SonarCloud_cliProjectName}}
        cliSources: '$(Build.SourcesDirectory)'
        extraProperties: |
          sonar.javascript.lcov.reportPaths=$(SONAR_LCOV_PATHS)
          sonar.typescript.lcov.reportPaths=$(SONAR_LCOV_PATHS)
          sonar.scanner.metadataFilePath=$(Agent.TempDirectory)/sonar/$(Build.BuildNumber)/test/report-task.txt
          sonar.cpd.exclusions=**/*.test.ts,**/generated.tsx
          sonar.coverage.exclusions=**/*.config.ts,**/tsconfig.json,**/.storybook/**,**/*.stories.ts,**/*.stories.tsx,**/*.test.ts,**/*.test.tsx,**/generated.ts,**/generated.tsx,**/*.d.ts,dist/**,apps/docs/src/test/**,scripts/**,packages/ocom/domain/tests/**,packages/cellix/mock-oauth2-server/**,packages/cellix/mock-mongodb-memory-server/**

    # SonarCloud: Analyze code and code coverage
    - task: SonarCloudAnalyze@3
      displayName: 'SonarCloud: Run analysis'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))

    # SonarCloud: Publish analysis results and wait until completion
    - task: SonarCloudPublish@3
      displayName: 'SonarCloud: Publish results on build summary'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        pollingTimeoutSec: '300'

    # SonarCloud: Break the build if it doesn't pass the Quality Gate
    - task: sonarcloud-buildbreaker@2
      displayName: 'SonarCloud: Break the build if it does not pass the Quality'
      condition: and(succeeded(), eq(${{parameters.disableSonarCloudTasks}}, False))
      inputs:
        SonarCloud: ${{parameters.SonarCloud}}
        organization: ${{parameters.SonarCloud_organization}}

    # Package compiled assets into artifact
    - task: ArchiveFiles@2
      displayName: 'Artifact: Prepare'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/'
        includeRootFolder: false
        archiveType: zip
        archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
        replaceExistingArchive: true
        # Include all build outputs from packages and apps

    # Upload artifact as build result
    - publish: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
      displayName: 'Artifact: Publish'
      condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
      artifact: drop